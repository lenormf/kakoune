= Commands

Some commands take a trailing exclamation mark (`!`), which can be used to
force the execution of the command (e.g. to quit a modified buffer, command
`:quit!` has to be used). Aliases are mentioned below each commands.

*doc* <topic>::
    _alias_ help +
    display documentation about a topic. The completion list displays all
    available topics.

== Files and Buffers

For the following *write* commands, the *-sync* switch forces the synchronisation
of the given file onto the filesystem

*buffer* <name>::
    _alias_ b +
    switch to buffer *name*.

*buffer-next*::
    _alias_ bn +
    switch to the next buffer.

*buffer-prev*::
    _alias_ bp +
    switch to the previous buffer.

*change-directory* [<directory>]::
    _alias_ cd +
    change the current directory to *directory*, or the home directory if
    unspecified.

*delete-buffer[!]* [<name>]::
    _alias_ db +
    delete the current buffer or buffer *name* if specified.

*edit[!]* <filename> [<line> [<column>]]::
    _alias_ e +
    open *filename* in a new buffer, then jump to the given *line*
    and *column*. If the file was already open, just switch to this file
    Use `edit!` to force reloading.

*quit[!]* [<exit status>]::
    _alias_ q +
    exit the current client. If specified, the client exit status will be
    set to *exit status*. Use `quit!` to force quitting even if unsaved
    buffers are still open.

*rename-buffer* <name>::
    set the current buffer's name to *name*.

*source* <filename> <param>...::
    execute commands in file *filename*.
    parameters are available in the sourced script through the `arg` values,
    accessible through `$1`, `$2` etc in shells, or `%arg{1}`, `%arg{2}`
    etc in commands.

*write[!]* [-sync] [<filename>]::
    _alias_ w +
    write the current buffer to *filename* or use its name if no filename is
    passed. Use `write!` if the file is write-protected, in order to temporarily
    change its permissions and save the buffer.

*write-all* [-sync]::
    _alias_ wa +
    write all buffers that are associated to a file.

*write-all-quit* [-sync] [<exit status>]::
    _alias_ waq +
    write all buffers and quit. If specified, the client exit status
    will be set to *exit status*.

*write-quit[!]* [-sync] [<exit status>]::
    _alias_ wq +
    write the current buffer and quit the current client. If specified,
    the client exit status will be set to *exit status*.

== Clients and Sessions

*kill[!]* [<exit status>]::
    terminate the current session, all the clients as well as the server.
    If specified, the server and clients exit status will be set to *exit
    status*. Use `kill!` to terminate the current session even if unsaved
    buffers are still open.

*rename-client* <name>::
    _alias_ nc +
    set the current client's name to *name*.

*rename-session* <name>::
    set the current session's name to *name*.

== Options

*declare-option* [<switches>] <type> <name> [<value>]::
    _alias_ decl +
    declare a new option (see <<options#declare-option,`:doc options declare-option`>>).

*set-option* [<switches>] <scope> <name> <value>::
    _alias_ set +
    change the value of an option
    note that the name of a particular buffer can be specified when the
    target *scope* is *buffer*, e.g. `set buffer=/path/to/buffer foo "bar"`;
    *scope* can also be special value `current`, which will automatically
    point to the narrowest scope available in the current context (see <<options#set-option,`:doc options set-option`>>).

*unset-option* <scope> <name>::
    _alias_ unset +
    unset the value of an option (see <<options#unset-option,`:doc options unset-option`>>).

*update-option* <scope> <name>::
    update the value of an option if its type supports that operation (see <<options#update-option,`:doc options update-option`>>).

== Commands and Keys

*alias* <scope> <name> <command>::
    define a new alias, within the context of a scope.

*declare-user-mode* <name>::
    declare a new user keymap mode named *name*.

*define-command* [<switches>] <name> <command>::
    _alias_ def +
    define a new command (see <<declaring-new-commands,Declaring new commands>>).

*enter-user-mode* [<switches>] <name>::
    enable keymap mode *name* for the next key.

    Switches:

    *-lock*:::
        stay in mode until `<esc>` is pressed

*evaluate-commands* [<switches>] <command> ...::
    _alias_ eval +
    evaluate *command*, as if they were entered in the command prompt (see <<execeval#,`:doc execeval`>>).

*execute-keys* [<switches>] <key> ...::
    _alias_ exec +
    execute a series of keys, as if they had been hit directly (see <<execeval#,`:doc execeval`>>).

*map* [<switches>] <scope> <mode> <key> <keys>::
    bind a list of keys to a single key (see <<mapping#,`:doc mapping`>>).

*unalias* <scope> <name> [<command>]::
    remove an alias if its current value is the same as the one passed
    as an optional parameter, remove it unconditionally otherwise.

*unmap* <scope> <mode> <key> [<expected>]::
    unbind a key if it's currently mapped to keys *expected*, unbind it
    unconditionally otherwise (see <<mapping#,`:doc mapping`>>).

== Hooks

*hook* [-group <group>] <scope> <hook_name> <filtering_regex> <command>::
    execute a command whenever an event is triggered (see <<hooks#,`:doc hooks`>>).

*remove-hooks* <scope> <group>::
    _alias_ rmhooks +
    remove every hooks in *scope* that are part of the given *group* (see <<hooks#,`:doc hooks`>>)..

== Display

*add-highlighter* <highlighter_name> <highlighter_parameters> ...::
    _alias_ addhl +
    add a highlighter to the current window (see <<highlighters#,`:doc highlighters`>>).

*colorscheme* <name>::
    load colorscheme *name*.

*echo* [<switches>] <text>::
    show *text* in the status line.

    Switches:

    *-debug*:::
        print the given text to the *\*debug** buffer

    *-markup*:::
        expand the markup strings in *text*(See <<expansions#markup-strings,`:doc expansions markup-strings`>>)

*remove-highlighter* <highlighter_id>::
    _alias_ rmhl +
    remove the highlighter whose id is *highlighter_id* (see <<highlighters#,`:doc highlighters`>>).

*set-face* <scope> <name> <facespec>::
    _alias_ face +
    define a face in the given *scope* (see <<faces#,`:doc faces`>>).

*unset-face* <scope> <name>::
    remove a face definition from the given *scope* (see <<faces#,`:doc faces`>>).

== Helpers

Kakoune provides some helper commands that can be used to define composite
commands in scripts. They are also available in the interactive mode,
but not really useful in that context.

*debug* {info,buffers,options,memory,shared-strings,profile-hash-maps,faces,mappings}::
    print debug information in the *\*debug** buffer.

*fail* <text>::
    raise an error described by *text*.

*info* [<switches>] <text>::
    display *text* in an information box.

    Switches:

    *-anchor* <line>.<column>:::
        print the text at the given coordinates

    *-placement* {above,below}:::
        set the placement relative to the anchor

    *-title* <text>:::
        set the title of the message box to *text*

*menu* [<switches>] <label1> <commands1> <label2> <commands2> ...::
    display a menu using labels, the selected labelâ€™s commands are
    executed. The *menu* command can take an *-auto-single* argument, to automatically
    run commands when only one choice is provided, and a *-select-cmds*
    argument, in which case menu takes three argument per item, the
    last one being a command to execute when the item is selected (but
    not validated)

*nop* [<params>]...::
    do nothing, but arguments passed to the command will be evaluated (e.g. shell expansion).

*on-key* <command>::
    wait for a key to be hit, then execute *command*; the key is
    available through the `key` value, accessible through `$kak_key`
    in shells, or `%val{key}` in commands.

*prompt* [<switches>] <prompt> <command>::
    prompt the user for a string, when the user validates, executes the
    command. The entered text is available in the `text` value accessible
    through `$kak_text` in shells or `%val{text}` in commands.

    Switches:

    *-init <str>*:::
        set the initial prompt contents to the given string

    *-password*:::
        hide the entered text and clear the register after command execution

    The *-on-change* and *-on-abort* switches, followed by a command
    will have this command executed whenever the prompt content changes
    or the prompt is aborted, respectively.

*select* <anchor_line>.<anchor_column>,<cursor_line>.<cursor_column>...::
    replace the current selection with the one represented by the description
    passed as argument.

*set-register* <name> <contents>...::
    _alias_ reg +
    set register *name* to *contents*, each parameter is assigned to a
    different string in the register (see <<registers#,`:doc registers`>>).

*try* <commands> [catch <on_error_commands>]...::
    if an error that would normally break the execution flow in *commands*
    arise, execute *on_error_commands* instead. If an error is raised in
    *on_error_commands*, that error is propagated to the next *catch* block,
    or to the parent scope if no more are declared.

== Multiple commands

Commands (c.f. previous sections) can be chained, by being separated either
by new lines or by semicolons. To be considered a literal semicolon argument
(i.e. escaped), a backslash character must be prepended to it: `\\;`.

== Declaring new commands

New commands can be defined using the *define-command* command:

*define-command* [<switches>] <command_name> <commands>::
    *commands* is a string containing the commands to execute.

    Switches:

    *-docstring*:::
        define the documentation string for the command

    *-hidden*:::
        do not show the command in command name completions

    *-override*:::
        allow the new command to replace an existing one with the same name

    *-params* <num>:::
        the command accepts a *num* parameter, which can be either a number,
        or of the form `<min>..<max>`, with both *min* and *max* optional

    *-buffer-completion*:::
        try buffer name completion on any parameter passed to this command

    *-client-completion*:::
        try client name completion on any parameter passed to this command

    *-command-completion*:::
        try command completion on any parameter passed to this command

    *-file-completion*:::
        try file completion on any parameter passed to this command

    *-shell-completion*:::
        the argument passed to this switch is a shell command which takes
        positional parameters and outputs one completion candidate
        per line. The provided shell command will run after each keypress.

        During the execution of the shell command, the following environment
        variables are available:

        - *kak_token_to_complete*::::
            index of the token being completed in the command line

        - *kak_pos_in_token*::::
            position of the cursor inside the token being completed, in bytes
            from token start

    *-shell-candidates*:::
        the argument passed to this switch is a shell command which takes
        positional parameters and outputs one completion candidate per
        line. The provided shell command will run once at the beginning
        of each completion session; candidates are cached and then used by
        the internal fuzzy matching engine

        During the execution of the shell command, the following environment
        variables are available:

        - *kak_token_to_complete*::::
            index of the token being completed in the command line

Using shell expansion allows defining complex commands or accessing
Kakoune's state:

--------------------------------------------------------
def " print_selection %{ echo %sh{ ${kak_selection} } }"
--------------------------------------------------------
