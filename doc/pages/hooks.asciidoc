= Hooks

== Description

Commands can be registered to be executed when certain events arise. To
register a hook use the following command:

----------------------------------------------------------------------
hook [-group <group>] <scope> <hook_name> <filtering_regex> <commands>
----------------------------------------------------------------------

*scope* can be one of *global*, *buffer* or *window* (see
<<scopes#,`:doc scopes`>>).

*command* is a string containing the commands to execute when the hook
is called.

For example, to automatically use line numbering with .cc files, use the
following command:

--------------------------------------------------------------
hook global WinCreate .*\.cc %{ add-highlighter number-lines }
--------------------------------------------------------------

If a *group* is given, make this hook part of the named group. Groups are
used for removing hooks with the following command:

----------------------------
remove-hooks <scope> <group>
----------------------------

A call to the command above will remove all hooks in *scope* that are part
of the given *group*.

Hooks declared with the *-once* switch are automatically removed after
having been run.

== Default hooks

*BufClose* `buffer name`::
    a buffer is about to be deleted.

*BufCreate* `filename`::
    a buffer was created.

*BufNewFile* `filename`::
    a buffer for a new file was created.

*BufOpenFile* `filename`::
    a buffer for an existing file was created.

*BufCloseFifo*::
    a fifo buffer closed its fifo file descriptor, either because the buffer
    is being deleted or the writing end was closed.

*BufOpenFifo* `buffer name`::
    a buffer opened a fifo.

*BufReadFifo* `buffer name`::
    some data was read from a fifo and was inserted in a buffer.

*BufReload* `filename`::
    a buffer reload was triggered by an external modification to its file.

*BufSetOption* `<option_name>=<new_value>`::
    *option_name* was set in a buffer context.

*BufWritePost* `filename`::
    a buffer was saved.

*BufWritePre* `filename`::
    a buffer is about to be saved.

*FocusIn* `client_name`::
    on supported clients, *client_name* was focused.

*FocusOut* `client_name`::
    on supported clients, *client_name* was unfocused.

*GlobalSetOption* `<option_name>=<new_value>`::
    *option_name* was set in the global context.

*InsertBegin*::
    entering insert mode.

*InsertCompletionSelect* `selected completion`::
    an entry was selected in the insert completion menu. The filtering text
    is the selected completion text or an empty string if the original
    text was selected back.

*InsertCompletionShow*::
    the insert completion menu was displayed.

*InsertCompletionHide*::
    the insert completion menu was hidden.

*InsertChar* `character`::
    *character* was received in insert mode.

*InsertDelete* `character`::
    *character* was deleted in insert mode.

*InsertEnd*::
    leaving insert mode.

*InsertIdle*::
    a certain duration has passed since the last key was hit, in insert mode.

*InsertKey* `key`::
    *key* was hit in insert mode.

*InsertMove* `move key`::
    the cursor moved (without inserting) in insert mode.

*KakBegin* `session name`::
    kakoune has started (called just after the user configuration
    files were read).

*KakEnd*::
    kakoune is quitting.

*ModeChange* `<old_mode>:<new_mode>`::
    the current input mode has changed from *old_mode* to *new_mode*.

*NormalBegin*::
    entering normal mode.

*NormalEnd*::
    leaving normal mode.

*NormalIdle*::
    a certain duration has passed since the last key was hit, in normal mode.

*NormalKey* `key`::
    *key* was hit in normal mode.

*PromptIdle*::
    a certain duration has passed since the last key was hit, in prompt mode.

*RawKey* `key`::
    *key* was hit by the user.

*RuntimeError* `error message`::
    an error was triggered while executing a user command.

*WinClose* `buffer name`::
    a window was destroyed.

*WinCreate* `buffer name`::
    a window was created.

*WinDisplay* `buffer name`::
    a window was bound a client.

*WinResize* `<line>.<column>`::
    a window was resized.

*WinSetOption* `<option_name>=<new_value>`::
    *option_name* was set in a window's context.

When not specified, the filtering text is an empty string. Note that
some hooks will not consider underlying scopes depending on what context
they are bound to be run into, e.g. the *BufWritePost* hook is a buffer
hook, and will not consider the *window* scope.

Additional environment variabes are expanded within `%sh{}` blocks, when
defining hooks:

* *kak_hook_param*: filtering text passed to the currently executing hook.

* *kak_hook_param_capture_<n>*: text captured by the hook filter regex capture *n*.

== Disabling Hooks

Any normal mode command can be prefixed with `\\` which will disable hook
execution for the duration of the command (including the duration of modes
the command could move to, so `\i` will disable hooks for the whole duration
of the subsequent insert session).

As autoindentation is implemented with hooks, this mechanism can be used
to disable it when pasting text.

A more permanent alternative is to set the `disabled_hooks` option which
accepts a regex describing which hooks won't be executed.  For example
indentation hooks can be disabled with '.*-indent'.

Finally, hook execution can be disabled while using the `execute-keys` or
`evaluate-commands` commands by using the `-no-hooks` switch
(see <<execeval#,`:doc execeval`>>).

As an exception to these rules, hooks declared with the `-always` switch
are triggered no matter what. A good use case is doing some cleanup on
`BufCloseFifo`.
